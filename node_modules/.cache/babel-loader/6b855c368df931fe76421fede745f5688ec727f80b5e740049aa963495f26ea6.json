{"ast":null,"code":"const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\nclass ApiService {\n  async makeRequest(endpoint, options = {}) {\n    const url = `${API_BASE_URL}${endpoint}`;\n    const defaultOptions = {\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers\n      },\n      ...options\n    };\n    try {\n      const response = await fetch(url, defaultOptions);\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.message || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error(`API request failed for ${endpoint}:`, error);\n      throw error;\n    }\n  }\n\n  // Create a new meeting bot\n  async createBot(request) {\n    console.log('Creating bot with request:', request);\n    return this.makeRequest('/api/v1/bots/', {\n      method: 'POST',\n      body: JSON.stringify(request)\n    });\n  }\n\n  // Get meeting transcripts\n  async getTranscripts(meetingId) {\n    return this.makeRequest(`/meeting/${meetingId}/transcripts`);\n  }\n\n  // Get meeting report\n  async getReport(meetingId) {\n    return this.makeRequest(`/meeting/${meetingId}/report`);\n  }\n\n  // Poll for report with exponential backoff\n  async pollForReport(meetingId, maxAttempts = 10) {\n    let attempt = 0;\n    let delay = 2000; // Start with 2 seconds\n\n    while (attempt < maxAttempts) {\n      try {\n        const report = await this.getReport(meetingId);\n\n        // If report is available, return it\n        if (report.reports && report.reports.length > 0) {\n          return report;\n        }\n\n        // If meeting is still in progress, wait longer\n        if (report.status === 'started') {\n          await new Promise(resolve => setTimeout(resolve, 10000)); // Wait 10 seconds\n        } else {\n          // If report is being generated, use exponential backoff\n          await new Promise(resolve => setTimeout(resolve, delay));\n          delay = Math.min(delay * 1.5, 30000); // Max 30 seconds\n        }\n        attempt++;\n      } catch (error) {\n        console.error(`Poll attempt ${attempt + 1} failed:`, error);\n        await new Promise(resolve => setTimeout(resolve, delay));\n        delay = Math.min(delay * 1.5, 30000);\n        attempt++;\n      }\n    }\n    throw new Error('Report polling timed out');\n  }\n\n  // Get all bots (this would need to be implemented on the backend)\n  async getBots() {\n    // Note: This endpoint is not in the API docs, so we'll return empty array\n    // You may need to implement this on your backend or store bots locally\n    return [];\n  }\n}\n\n// Create singleton instance\nconst apiService = new ApiService();\nexport default apiService;","map":{"version":3,"names":["API_BASE_URL","process","env","REACT_APP_API_URL","ApiService","makeRequest","endpoint","options","url","defaultOptions","headers","response","fetch","ok","errorData","json","catch","Error","message","status","error","console","createBot","request","log","method","body","JSON","stringify","getTranscripts","meetingId","getReport","pollForReport","maxAttempts","attempt","delay","report","reports","length","Promise","resolve","setTimeout","Math","min","getBots","apiService"],"sources":["/Users/allancrawford/Cursor/meahana/src/services/api.ts"],"sourcesContent":["import { \n  CreateBotRequest, \n  CreateBotResponse, \n  MeetingBot, \n  TranscriptData, \n  ReportData \n} from '../types';\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n\nclass ApiService {\n  private async makeRequest<T>(\n    endpoint: string, \n    options: RequestInit = {}\n  ): Promise<T> {\n    const url = `${API_BASE_URL}${endpoint}`;\n    \n    const defaultOptions: RequestInit = {\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers,\n      },\n      ...options,\n    };\n\n    try {\n      const response = await fetch(url, defaultOptions);\n      \n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.message || `HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error(`API request failed for ${endpoint}:`, error);\n      throw error;\n    }\n  }\n\n  // Create a new meeting bot\n  async createBot(request: CreateBotRequest): Promise<CreateBotResponse> {\n    console.log('Creating bot with request:', request);\n    return this.makeRequest<CreateBotResponse>('/api/v1/bots/', {\n      method: 'POST',\n      body: JSON.stringify(request),\n    });\n  }\n\n  // Get meeting transcripts\n  async getTranscripts(meetingId: number): Promise<TranscriptData> {\n    return this.makeRequest<TranscriptData>(`/meeting/${meetingId}/transcripts`);\n  }\n\n  // Get meeting report\n  async getReport(meetingId: number): Promise<ReportData> {\n    return this.makeRequest<ReportData>(`/meeting/${meetingId}/report`);\n  }\n\n  // Poll for report with exponential backoff\n  async pollForReport(meetingId: number, maxAttempts: number = 10): Promise<ReportData> {\n    let attempt = 0;\n    let delay = 2000; // Start with 2 seconds\n\n    while (attempt < maxAttempts) {\n      try {\n        const report = await this.getReport(meetingId);\n        \n        // If report is available, return it\n        if (report.reports && report.reports.length > 0) {\n          return report;\n        }\n\n        // If meeting is still in progress, wait longer\n        if (report.status === 'started') {\n          await new Promise(resolve => setTimeout(resolve, 10000)); // Wait 10 seconds\n        } else {\n          // If report is being generated, use exponential backoff\n          await new Promise(resolve => setTimeout(resolve, delay));\n          delay = Math.min(delay * 1.5, 30000); // Max 30 seconds\n        }\n\n        attempt++;\n      } catch (error) {\n        console.error(`Poll attempt ${attempt + 1} failed:`, error);\n        await new Promise(resolve => setTimeout(resolve, delay));\n        delay = Math.min(delay * 1.5, 30000);\n        attempt++;\n      }\n    }\n\n    throw new Error('Report polling timed out');\n  }\n\n  // Get all bots (this would need to be implemented on the backend)\n  async getBots(): Promise<MeetingBot[]> {\n    // Note: This endpoint is not in the API docs, so we'll return empty array\n    // You may need to implement this on your backend or store bots locally\n    return [];\n  }\n}\n\n// Create singleton instance\nconst apiService = new ApiService();\n\nexport default apiService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}